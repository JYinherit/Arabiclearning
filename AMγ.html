<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é’§é¸¢çš„é˜¿æ‹‰ä¼¯è¯­è®°å¿†Î³</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            text-align: center;
        }
        .container {
            background-color: #fff;
            padding: 2rem 3rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 600px;
        }
        #start-screen h1 {
            color: #004d40;
        }
        .btn {
            display: inline-block;
            padding: 12px 24px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            margin: 0.5rem;
        }
        /* Style for deck selection buttons */
        #deck-selection-container .deck-btn {
            background-color: #00695c;
            width: 80%;
            margin: 0.6rem auto;
        }
        #deck-selection-container .deck-btn:hover {
            background-color: #004d40;
        }
        #card-container {
            display: none;
        }
        #word-display {
            font-size: 2.5rem;
            font-weight: bold;
            color: #004d40;
            margin-bottom: 1rem;
            min-height: 80px; /* Ensure consistent height */
        }
        #answer-display {
            font-size: 2rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            padding: 1rem;
            border-radius: 8px;
            transition: background-color 0.3s, color 0.3s;
            line-height: 1.5;
            min-height: 60px; /* Ensure consistent height */
        }
              #explanation-display {
            font-size: 1.1rem;
            color: #616161;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e0e0e0;
            text-align: left;
            min-height: 40px;
        }
        .spoiler {
            background-color: #212121;
            color: #212121;
            cursor: pointer;
            user-select: none;
        }
        .spoiler.revealed {
            background-color: #f5f5f5;
            color: #c62828;
            cursor: default;
        }
/* å¼ºåˆ¶ .spoiler è§„åˆ™è¦†ç›– #explanation-display çš„ ID è§„åˆ™ */
#explanation-display.spoiler {
    color: #212121;/* åŒ¹é…èƒŒæ™¯è‰²ä»¥éšè—[span_0](end_span) */
    background-color: #212121;/* åŒ¹é…èƒŒæ™¯è‰²ä»¥éšè—[span_1](end_span) */
    border-top: none; /* éšè—çŠ¶æ€ä¸‹ä¸æ˜¾ç¤ºåˆ†éš”çº¿ */
}

/* å¼ºåˆ¶ .revealed è§„åˆ™ä½¿ç”¨è§£é‡Šæœ¬æ¥çš„é¢œè‰²ï¼ˆç°è‰²ï¼‰ï¼Œè€Œä¸æ˜¯ç­”æ¡ˆçš„çº¢è‰² */
#explanation-display.spoiler.revealed {
    color: #616161; /* æ¢å¤ä¸ºè§£é‡Šçš„åŸå§‹é¢œè‰²[span_2](end_span) */
    background-color: #fff; /* æ¢å¤ä¸ºå®¹å™¨èƒŒæ™¯è‰²[span_3](end_span) */
    border-top: 1px solid #e0e0e0; /* æ¢å¤åˆ†éš”çº¿[span_4](end_span) */
}
        #controls {
             margin-top: 1.5rem;
        }
        #controls .btn {
            width: 120px;
        }
        #remembered-btn { background-color: #43a047; }
        #remembered-btn:hover { background-color: #388e3c; transform: translateY(-2px); }
        #forgot-btn { background-color: #e53935; }
        #forgot-btn:hover { background-color: #d32f2f; transform: translateY(-2px); }
        #completion-screen {
            display: none;
        }
        #completion-screen h2 {
            color: #2e7d32;
            font-size: 2rem;
        }

        /* --- New Styles --- */
        #progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-bottom: 2rem;
        }
        #progress-bar {
            width: 0%;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 5px;
            text-align: center;
            line-height: 20px;
            color: white;
            font-weight: bold;
            transition: width 0.5s ease-in-out;
        }
        #nav-controls {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #e0e0e0;
        }
        #nav-controls .btn {
            background-color: #607d8b;
            font-size: 0.9rem;
            padding: 10px 20px;
            width: auto;
        }
        #nav-controls .btn:hover {
            background-color: #546e7a;
        }
        #nav-controls .btn:disabled {
            background-color: #bdbdbd;
            cursor: not-allowed;
            transform: none;
        }
        #mode-selection-container {
            margin-bottom: 2rem;
            text-align: left;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 1.5rem;
        }
        #mode-selection-container label {
            display: block;
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        #mode-selection-container label:hover {
            background-color: #f0f2f5;
        }
        #mode-selection-container input[type="radio"] {
            margin-right: 10px;
            accent-color: #00695c;
            transform: scale(1.1);
        }
        /* å¯¼å…¥è¯åº“ç›¸å…³æ ·å¼ */
        #import-section {
            margin-top: 2rem;
            padding-top: 2rem;
        }

        .import-divider {
            width: 100%;
            height: 1px;
            background: linear-gradient(to right, transparent, #e0e0e0, transparent);
            margin-bottom: 1.5rem;
        }

        #import-section h3 {
            color: #37474f;
            margin-bottom: 1rem;
        }

        .import-btn {
            background-color: #1976d2;
            width: 80%;
            margin: 0.6rem auto;
        }

        .import-btn:hover {
            background-color: #1565c0;
        }

        #import-info {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #757575;
        }

        #import-info details {
            margin-top: 0.5rem;
            text-align: left;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
        }

        #import-info summary {
            cursor: pointer;
            color: #1976d2;
            font-weight: 500;
        }

        #import-info summary:hover {
            text-decoration: underline;
        }

        .format-example {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f5f5f5;
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .format-example pre {
            background-color: #fff;
            padding: 0.75rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 0.5rem 0;
            border: 1px solid #e0e0e0;
        }

        /* å¯¼å…¥æˆåŠŸ/å¤±è´¥æç¤º */
        .import-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .import-success {
            background-color: #43a047;
        }

        .import-error {
            background-color: #e53935;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>

    <div class="container">
    <div id="start-screen">
        <h1>é€‰æ‹©è¯åº“</h1>

        <div id="mode-selection-container">
            <label>
                <input type="radio" name="mode" value="zh-ar" checked> æ˜¾ç¤ºä¸­æ–‡èƒŒé˜¿è¯­
            </label>
            <label>
                <input type="radio" name="mode" value="ar-zh"> æ˜¾ç¤ºé˜¿è¯­èƒŒä¸­æ–‡
            </label>
            <label>
                <input type="radio" name="mode" value="mixed"> æ··åˆæ¨¡å¼
            </label>
        </div>

        <div id="deck-selection-container">
        </div>

        <div id="import-section">
            <div class="import-divider"></div>
            <h3>å¯¼å…¥æ–°è¯åº“</h3>
            <input type="file" id="file-input" accept=".json,.csv,.js,.txt" style="display: none;">
            <button id="import-btn" class="btn import-btn">
              ğŸ“ é€‰æ‹©æ–‡ä»¶å¯¼å…¥
            </button>
            <div id="import-info">
                <p>æ”¯æŒæ ¼å¼ï¼šJSONã€CSVã€JSå¯¹è±¡</p>
                <details>
                    <summary>æŸ¥çœ‹æ ¼å¼è¦æ±‚</summary>
                    <div class="format-example">
                        <strong>æ ¼å¼1 - å¤šè¯åº“æ‰¹é‡å¯¼å…¥ï¼ˆæ¨èï¼‰ï¼š</strong>
                        <pre>{
    "ç¬¬äºŒè¯¾ï¼šä½ å¥½": [
        {
        "chinese": "è° (ç–‘é—®ä»£è¯)",
        "arabic": "Ù…ÙÙ†Ù’",
        "explanation": "Ù…ÙÙ†Ù’ Ù‡ÙÙˆÙØŸ (ä»–æ˜¯è°ï¼Ÿ)"
        }
    ],
    "ç¬¬ä¸‰è¯¾ï¼šä½ å«ä»€ä¹ˆåå­—": [...]
    }</pre>
                        <strong>æ ¼å¼2 - å•è¯åº“JSONï¼š</strong>
                        <pre>{
    "deckName": "åŸºç¡€è¯æ±‡",
    "words": [
        {
        "chinese": "ä½ å¥½",
        "arabic": "Ù…Ø±Ø­Ø¨Ø§",
        "explanation": "å¸¸ç”¨é—®å€™è¯­"
        }
    ]
    }</pre>
                        <strong>æ ¼å¼3 - CSVè¡¨æ ¼ï¼š</strong>
                        <pre>ä¸­æ–‡,é˜¿æ‹‰ä¼¯è¯­,è§£é‡Š
    ä½ å¥½,Ù…Ø±Ø­Ø¨Ø§,å¸¸ç”¨é—®å€™è¯­
    è°¢è°¢,Ø´ÙƒØ±Ø§,è¡¨ç¤ºæ„Ÿè°¢</pre>
                    </div>
                </details>
            </div>
        </div>
    </div>

        <div id="card-container">
            <div id="progress-container">
                <div id="progress-bar">0%</div>
            </div>
            <h2 id="word-display"></h2>
            <div id="answer-display" class="spoiler" title="ç‚¹å‡»æ˜¾ç¤º/éšè—ç­”æ¡ˆ"></div>
   <p id="explanation-display" class="spoiler"></p>


            <div id="controls">
                <button id="remembered-btn" class="btn">è®°ä½äº†</button>
                <button id="forgot-btn" class="btn">æ²¡è®°ä½</button>
            </div>
            <div id="nav-controls">
                <button id="prev-btn" class="btn">ä¸Šä¸€ä¸ªè¯</button>
                <button id="back-to-menu-btn" class="btn">è¿”å›èœå•</button>
            </div>
        </div>

        <div id="completion-screen">
            <h2>ğŸ‰ æ­å–œä½ å®Œæˆäº†æœ¬è¯åº“çš„è®°å¿† ğŸ‰</h2>
            <p>æ‰€æœ‰å•è¯éƒ½å·²ç‰¢ç‰¢è®°ä½ï¼</p>
            <button id="finish-back-to-menu-btn" class="btn" style="background-color: #00695c;">è¿”å›èœå•</button>
        </div>
    </div>

    <script>
        // --- NEW: Vocabulary Decks ---
        const vocabularyDecks = {

        };

        // è·å–DOMå…ƒç´ 
        const startScreen = document.getElementById('start-screen');
        const cardContainer = document.getElementById('card-container');
        const completionScreen = document.getElementById('completion-screen');
        const deckSelectionContainer = document.getElementById('deck-selection-container');
        
        const wordDisplay = document.getElementById('word-display');
        const answerDisplay = document.getElementById('answer-display');
        const explanationDisplay = document.getElementById('explanation-display');
        
        const rememberedBtn = document.getElementById('remembered-btn');
        const forgotBtn = document.getElementById('forgot-btn');
        const prevBtn = document.getElementById('prev-btn');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        const finishBackToMenuBtn = document.getElementById('finish-back-to-menu-btn');

        const progressBar = document.getElementById('progress-bar');

        let activeWords = [];
        let currentWord = null;
        let historyStack = [];
        let currentMode = 'zh-ar'; // ç”¨äºå­˜å‚¨å½“å‰é€‰æ‹©çš„æ¨¡å¼
        // å¯¼å…¥åŠŸèƒ½ç›¸å…³å˜é‡
        const fileInput = document.getElementById('file-input');
        const importBtn = document.getElementById('import-btn');

        // æ˜¾ç¤ºå¯¼å…¥æ¶ˆæ¯
        function showImportMessage(message, isSuccess = true) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `import-message ${isSuccess ? 'import-success' : 'import-error'}`;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 3000);
        }

        // è§£æCSVæ–‡ä»¶
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSVæ–‡ä»¶æ ¼å¼é”™è¯¯ï¼šè‡³å°‘éœ€è¦æ ‡é¢˜è¡Œå’Œä¸€è¡Œæ•°æ®');
            }
            
            const words = [];
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',').map(part => part.trim());
                if (parts.length >= 2) {
                    words.push({
                        chinese: parts[0],
                        arabic: parts[1],
                        explanation: parts[2] || 'æš‚æ— è§£é‡Š'
                    });
                }
            }
            return words;
        }
        //è§£æjsonæ–‡ä»¶
        function parseJSON(jsonText) {
            try {
                // æ¸…ç†æ–‡æœ¬
                let cleanedText = jsonText.trim();
                
                // 1. å°è¯•ç›´æ¥è§£æä¸ºæ ‡å‡†JSON
                try {
                    const data = JSON.parse(cleanedText);
                    return processData(data);
                } catch (e) {
                    // ç»§ç»­å°è¯•å…¶ä»–æ ¼å¼
                }
                
                // 2. å¤„ç†å¯èƒ½çš„JavaScriptå¯¹è±¡æ ¼å¼
                // ç§»é™¤å¸¸è§çš„å˜é‡å£°æ˜
                cleanedText = cleanedText
                    .replace(/^(const|let|var)\s+\w+\s*=\s*/, '')  // ç§»é™¤å˜é‡å£°æ˜
                    .replace(/;[\s\n]*$/, '')  // ç§»é™¤æœ«å°¾åˆ†å·
                    .replace(/\/\*[\s\S]*?\*\//g, '')  // ç§»é™¤å¤šè¡Œæ³¨é‡Š
                    .replace(/\/\/.*$/gm, '');  // ç§»é™¤å•è¡Œæ³¨é‡Š
                
                // 3. æ£€æŸ¥æ˜¯å¦ç¼ºå°‘å¤–å±‚èŠ±æ‹¬å·
                cleanedText = cleanedText.trim();
                if (!cleanedText.startsWith('{')) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç›´æ¥çš„å±æ€§åˆ—è¡¨ï¼ˆå¦‚ "xxx": [...], "yyy": [...]ï¼‰
                    if (cleanedText.match(/^"[^"]+"\s*:/)) {
                        cleanedText = '{' + cleanedText;
                    }
                }
                if (!cleanedText.endsWith('}')) {
                    // ç§»é™¤æœ«å°¾å¯èƒ½çš„é€—å·
                    cleanedText = cleanedText.replace(/,\s*$/, '');
                    cleanedText = cleanedText + '}';
                }
                
                // 4. å°è¯•ä½œä¸ºJavaScriptå¯¹è±¡è§£æ
                try {
                    // ä½¿ç”¨æ›´å®‰å…¨çš„æ–¹å¼è§£æJavaScriptå¯¹è±¡
                    const data = new Function('return ' + cleanedText)();
                    return processData(data);
                } catch (e) {
                    // ç»§ç»­å°è¯•
                }
                
                // 5. æœ€åå°è¯•ï¼šä¿®å¤å¸¸è§çš„JSONé”™è¯¯
                cleanedText = cleanedText
                    .replace(/,\s*}/g, '}')  // ç§»é™¤å¯¹è±¡æœ«å°¾çš„é€—å·
                    .replace(/,\s*]/g, ']')  // ç§»é™¤æ•°ç»„æœ«å°¾çš„é€—å·
                    .replace(/'/g, '"')  // å°†å•å¼•å·æ›¿æ¢ä¸ºåŒå¼•å·
                    .replace(/(\w+):/g, '"$1":');  // ç»™æ²¡æœ‰å¼•å·çš„å±æ€§ååŠ å¼•å·
                
                const data = JSON.parse(cleanedText);
                return processData(data);
                
            } catch (error) {
                throw new Error(`è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚åŸå§‹é”™è¯¯ï¼š${error.message}`);
            }
        }

        // å¤„ç†è§£æåçš„æ•°æ®
        function processData(data) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯å•è¯åº“æ ¼å¼ï¼ˆæœ‰deckNameå’Œwordså­—æ®µï¼‰
            if (data.deckName && data.words && Array.isArray(data.words)) {
                // æ ¼å¼2ï¼šå•è¯åº“æ ¼å¼
                data.words.forEach((word, index) => {
                    if (!word.chinese || !word.arabic) {
                        throw new Error(`ç¬¬${index + 1}ä¸ªå•è¯ç¼ºå°‘å¿…è¦å­—æ®µï¼ˆchinese æˆ– arabicï¼‰`);
                    }
                    if (!word.explanation) {
                        word.explanation = 'æš‚æ— è§£é‡Š';
                    }
                });
                return { type: 'single', data: data };
            } else {
                // æ ¼å¼1ï¼šå¤šè¯åº“æ ¼å¼ï¼ˆå¯¹è±¡çš„æ¯ä¸ªå±æ€§éƒ½æ˜¯ä¸€ä¸ªè¯åº“ï¼‰
                const decks = {};
                let totalWords = 0;
                
                for (const [deckName, words] of Object.entries(data)) {
                    if (Array.isArray(words)) {
                        // éªŒè¯æ¯ä¸ªå•è¯
                        words.forEach((word, index) => {
                            if (!word.chinese || !word.arabic) {
                                throw new Error(`è¯åº“"${deckName}"çš„ç¬¬${index + 1}ä¸ªå•è¯ç¼ºå°‘å¿…è¦å­—æ®µ`);
                            }
                            if (!word.explanation) {
                                word.explanation = 'æš‚æ— è§£é‡Š';
                            }
                        });
                        decks[deckName] = words;
                        totalWords += words.length;
                    }
                }
                
                if (Object.keys(decks).length === 0) {
                    throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„è¯åº“æ•°æ®');
                }
        
        return { type: 'multiple', data: decks, totalWords: totalWords };
    }
}

        // å¤„ç†æ–‡ä»¶å¯¼å…¥
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    let importedCount = 0;
                    let importedDecks = [];
                    
                    if (file.name.endsWith('.csv')) {
                        // CSVæ ¼å¼å¤„ç†
                        const words = parseCSV(content);
                        let deckName = file.name.replace('.csv', '').replace(/[_-]/g, ' ');
                        
                        // å¦‚æœè¯åº“åç§°å·²å­˜åœ¨ï¼Œæ·»åŠ æ•°å­—åç¼€
                        let finalDeckName = deckName;
                        let counter = 1;
                        while (vocabularyDecks[finalDeckName]) {
                            finalDeckName = `${deckName} (${counter})`;
                            counter++;
                        }
                        
                        vocabularyDecks[finalDeckName] = words;
                        importedCount = words.length;
                        importedDecks.push(finalDeckName);
                        
                    } else {
                        // JSON/JSæ ¼å¼å¤„ç†
                        const result = parseJSON(content);
                        
                        if (result.type === 'single') {
                            // å•è¯åº“å¯¼å…¥
                            const data = result.data;
                            let deckName = data.deckName;
                            
                            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨
                            if (vocabularyDecks[deckName]) {
                                const overwrite = confirm(`è¯åº“"${deckName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`);
                                if (!overwrite) {
                                    // æ·»åŠ æ•°å­—åç¼€
                                    let counter = 1;
                                    while (vocabularyDecks[`${deckName} (${counter})`]) {
                                        counter++;
                                    }
                                    deckName = `${deckName} (${counter})`;
                                }
                            }
                            
                            vocabularyDecks[deckName] = data.words;
                            importedCount = data.words.length;
                            importedDecks.push(deckName);
                            
                        } else if (result.type === 'multiple') {
                            // å¤šè¯åº“æ‰¹é‡å¯¼å…¥
                            const decks = result.data;
                            let skippedDecks = [];
                            
                            for (const [deckName, words] of Object.entries(decks)) {
                                if (vocabularyDecks[deckName]) {
                                    const overwrite = confirm(`è¯åº“"${deckName}"å·²å­˜åœ¨ï¼ˆ${words.length}ä¸ªè¯ï¼‰ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`);
                                    if (!overwrite) {
                                        skippedDecks.push(deckName);
                                        continue;
                                    }
                                }
                                vocabularyDecks[deckName] = words;
                                importedDecks.push(deckName);
                                importedCount += words.length;
                            }
                            
                            // å¦‚æœæœ‰è·³è¿‡çš„è¯åº“ï¼Œæ˜¾ç¤ºæç¤º
                            if (skippedDecks.length > 0) {
                                setTimeout(() => {
                                    showImportMessage(`å·²è·³è¿‡ ${skippedDecks.length} ä¸ªå·²å­˜åœ¨çš„è¯åº“`, false);
                                }, 500);
                            }
                        }
                    }
                    
                    // åˆ·æ–°è¯åº“é€‰æ‹©ç•Œé¢
                    setupSelectionScreen();
                    
                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    if (importedDecks.length === 1) {
                        showImportMessage(`æˆåŠŸå¯¼å…¥è¯åº“"${importedDecks[0]}"ï¼ˆ${importedCount}ä¸ªå•è¯ï¼‰`);
                    } else {
                        showImportMessage(`æˆåŠŸå¯¼å…¥ ${importedDecks.length} ä¸ªè¯åº“ï¼ˆå…±${importedCount}ä¸ªå•è¯ï¼‰`);
                    }
                    
                    // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
                    fileInput.value = '';
                    
                } catch (error) {
                    showImportMessage(`å¯¼å…¥å¤±è´¥ï¼š${error.message}`, false);
                    fileInput.value = '';
                }
            };
            
            reader.readAsText(file, 'UTF-8');
        }

        // å¯¼å…¥æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        importBtn.addEventListener('click', () => {
            fileInput.click();
        });

        // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
        fileInput.addEventListener('change', handleFileImport);


        function setupSelectionScreen() {
            deckSelectionContainer.innerHTML = ''; // Clear previous buttons
            Object.keys(vocabularyDecks).forEach(deckName => {
                const button = document.createElement('button');
                button.textContent = deckName;
                button.className = 'btn deck-btn';
                if (vocabularyDecks[deckName].length === 0) {
                    button.disabled = true; // Disable empty decks
                    button.title = 'æ­¤è¯åº“æš‚æ— å†…å®¹';
                }
                button.addEventListener('click', () => startSession(vocabularyDecks[deckName]));
                deckSelectionContainer.appendChild(button);
            });
        }

        function showScreen(screen) {
            startScreen.style.display = 'none';
            cardContainer.style.display = 'none';
            completionScreen.style.display = 'none';
            screen.style.display = 'block';
        }
        
        function updateProgressBar() {
            if (activeWords.length === 0) return;
            const learnedCount = activeWords.filter(w => w.rememberedCount >= 3).length;
            const progress = Math.round((learnedCount / activeWords.length) * 100);
            progressBar.style.width = progress + '%';
            progressBar.textContent = progress + '%';
        }

                function displayCard(word) {
            explanationDisplay.textContent = `ğŸ’¡ è§£é‡Š: ${word.explanation}`;

            let showChinese = true; // é»˜è®¤æ˜¾ç¤ºä¸­æ–‡

            // æ ¹æ®å…¨å±€å˜é‡ currentMode å†³å®šæ˜¾ç¤ºå†…å®¹
            if (currentMode === 'mixed') {
                showChinese = Math.random() < 0.5; // æ··åˆæ¨¡å¼ï¼šéšæœº
            } else if (currentMode === 'ar-zh') {
                showChinese = false; // é˜¿èƒŒä¸­ï¼šä¸æ˜¾ç¤ºä¸­æ–‡
            }
            // (å¦‚æœ currentMode === 'zh-ar', showChinese ä¿æŒä¸º true)

            if (showChinese) {
                // æ¨¡å¼ "zh-ar" æˆ– æ··åˆæ¨¡å¼çš„ä¸­æ–‡é¢
                wordDisplay.textContent = word.chinese;
                wordDisplay.style.direction = 'ltr';
                answerDisplay.innerHTML = word.arabic.replace(/\n/g, '<br>');
                answerDisplay.style.direction = 'rtl';
            } else {
                // æ¨¡å¼ "ar-zh" æˆ– æ··åˆæ¨¡å¼çš„é˜¿è¯­é¢
                wordDisplay.innerHTML = word.arabic.replace(/\n/g, '<br>');
                wordDisplay.style.direction = 'rtl';
                answerDisplay.textContent = word.chinese;
                answerDisplay.style.direction = 'ltr';
            }

            // é‡ç½®ç­”æ¡ˆä¸ºéšè—çŠ¶æ€
            answerDisplay.classList.remove('revealed');
            answerDisplay.classList.add('spoiler');
            
            // é‡ç½®è§£é‡Šä¸ºéšè—çŠ¶æ€ (ç¡®ä¿è¿™ä¸€æ­¥ä¹ŸåŒ…å«åœ¨å†…)
            explanationDisplay.classList.remove('revealed');
            explanationDisplay.classList.add('spoiler');
        }

       function startSession(vocabulary) {
    // æ–°å¢ï¼šè¯»å–ç”¨æˆ·é€‰æ‹©çš„æ¨¡å¼
    const selectedMode = document.querySelector('input[name="mode"]:checked');
    if (selectedMode) {
        currentMode = selectedMode.value;
    } else {
        currentMode = 'zh-ar'; // é»˜è®¤å›é€€
    }

    initialize(vocabulary);
    showScreen(cardContainer);
    showNextWord();
}
    // é‡ç½®ç­”æ¡ˆä¸ºéšè—çŠ¶æ€
    answerDisplay.classList.remove('revealed');
    answerDisplay.classList.add('spoiler');
    // æ–°å¢ï¼šé‡ç½®è§£é‡Šä¸ºéšè—çŠ¶æ€    explanationDisplay.classList.remove('revealed');
    explanationDisplay.classList.add('spoiler');
        function initialize(vocabulary) {
            activeWords = vocabulary.map(word => ({
                ...word,
                rememberedCount: 0,
                cooldown: 0,
            }));
            historyStack = [];
            currentWord = null;
            updateProgressBar();
        }

        function showNextWord() {
            // Push the current word to history before getting the next one
            if (currentWord) {
                historyStack.push(currentWord);
            }
            prevBtn.disabled = historyStack.length === 0;

            activeWords.forEach(w => {
                if (w.cooldown > 0) w.cooldown--;
            });

            let wordsToLearn = activeWords.filter(w => w.rememberedCount < 3);

            if (wordsToLearn.length === 0) {
                showScreen(completionScreen);
                return;
            }

            let availablePool = wordsToLearn.filter(w => w.cooldown === 0);
            
            if (availablePool.length === 0) {
                wordsToLearn.sort((a, b) => a.cooldown - b.cooldown);
                currentWord = wordsToLearn[0];
            } else {
                const randomIndex = Math.floor(Math.random() * availablePool.length);
                currentWord = availablePool[randomIndex];
            }
            
            displayCard(currentWord);
            updateProgressBar();
        }
        
        // --- Event Listeners ---
        
answerDisplay.addEventListener('click', () => {
    // åˆ‡æ¢ç­”æ¡ˆçš„æ˜¾ç¤º
    answerDisplay.classList.toggle('spoiler');
    answerDisplay.classList.toggle('revealed');

    // åŒæ—¶åˆ‡æ¢è§£é‡Šçš„æ˜¾ç¤º
    explanationDisplay.classList.toggle('spoiler');
    explanationDisplay.classList.toggle('revealed');
});

        rememberedBtn.addEventListener('click', () => {
            if (!currentWord) return;
            currentWord.rememberedCount++;
            currentWord.cooldown = 11;
            showNextWord();
        });

        forgotBtn.addEventListener('click', () => {
            if (!currentWord) return;
            currentWord.cooldown = Math.floor(Math.random() * 4) + 2;
            showNextWord();
        });

        prevBtn.addEventListener('click', () => {
            if (historyStack.length > 0) {
                currentWord = historyStack.pop();
                displayCard(currentWord);
                prevBtn.disabled = historyStack.length === 0;
            }
        });

        const goBackToMenu = () => {
            showScreen(startScreen);
        };

        backToMenuBtn.addEventListener('click', goBackToMenu);
        finishBackToMenuBtn.addEventListener('click', goBackToMenu);

        // --- Initial Load ---
        window.onload = () => {
            setupSelectionScreen();
            showScreen(startScreen);
        };

    </script>

</body>
</html>
