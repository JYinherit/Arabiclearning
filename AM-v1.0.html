<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é’§é¸¢çš„é˜¿æ‹‰ä¼¯è¯­è®°å¿†</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            text-align: center;
        }
        .container {
            background-color: #fff;
            padding: 2rem 3rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 600px;
        }
        #start-screen h1 {
            color: #004d40;
        }
        .btn {
            display: inline-block;
            padding: 12px 24px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            margin: 0.5rem;
        }
        /* Style for deck selection buttons */
        #deck-selection-container .deck-btn {
            background-color: #00695c;
            width: 80%;
            margin: 0.6rem auto;
        }
        #deck-selection-container .deck-btn:hover {
            background-color: #004d40;
        }
        #card-container {
            display: none;
        }
        #word-display {
            font-size: 2.5rem;
            font-weight: bold;
            color: #004d40;
            margin-bottom: 1rem;
            min-height: 80px; /* Ensure consistent height */
        }
        #answer-display {
            font-size: 2rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            padding: 1rem;
            border-radius: 8px;
            transition: background-color 0.3s, color 0.3s;
            line-height: 1.5;
            min-height: 60px; /* Ensure consistent height */
        }
              #explanation-display {
            font-size: 1.1rem;
            color: #616161;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e0e0e0;
            text-align: left;
            min-height: 40px;
        }
        .spoiler {
            background-color: #212121;
            color: #212121;
            cursor: pointer;
            user-select: none;
        }
        .spoiler.revealed {
            background-color: #f5f5f5;
            color: #c62828;
            cursor: default;
        }
/* å¼ºåˆ¶ .spoiler è§„åˆ™è¦†ç›– #explanation-display çš„ ID è§„åˆ™ */
#explanation-display.spoiler {
    color: #212121;/* åŒ¹é…èƒŒæ™¯è‰²ä»¥éšè—[span_0](end_span) */
    background-color: #212121;/* åŒ¹é…èƒŒæ™¯è‰²ä»¥éšè—[span_1](end_span) */
    border-top: none; /* éšè—çŠ¶æ€ä¸‹ä¸æ˜¾ç¤ºåˆ†éš”çº¿ */
}

/* å¼ºåˆ¶ .revealed è§„åˆ™ä½¿ç”¨è§£é‡Šæœ¬æ¥çš„é¢œè‰²ï¼ˆç°è‰²ï¼‰ï¼Œè€Œä¸æ˜¯ç­”æ¡ˆçš„çº¢è‰² */
#explanation-display.spoiler.revealed {
    color: #616161; /* æ¢å¤ä¸ºè§£é‡Šçš„åŸå§‹é¢œè‰²[span_2](end_span) */
    background-color: #fff; /* æ¢å¤ä¸ºå®¹å™¨èƒŒæ™¯è‰²[span_3](end_span) */
    border-top: 1px solid #e0e0e0; /* æ¢å¤åˆ†éš”çº¿[span_4](end_span) */
}
        #controls {
             margin-top: 1.5rem;
        }
        #controls .btn {
            width: 120px; /* Default width for remembered/forgot buttons */
        }
        #next-word-in-history-btn {
            background-color: #00695c; /* Match deck selection button color */
            width: 80%; /* Make it wider and centered */
            margin: 0.5rem auto;
        }
        #next-word-in-history-btn:hover {
            background-color: #004d40;
        }
        #remembered-btn { background-color: #43a047; }
        #remembered-btn:hover { background-color: #388e3c; transform: translateY(-2px); }
        #forgot-btn { background-color: #e53935; }
        #forgot-btn:hover { background-color: #d32f2f; transform: translateY(-2px); }
        #completion-screen {
            display: none;
        }
        #completion-screen h2 {
            color: #2e7d32;
            font-size: 2rem;
        }

        /* --- New Styles --- */
        #progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-bottom: 2rem;
        }
        #progress-bar {
            width: 0%;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 5px;
            text-align: center;
            line-height: 20px;
            color: white;
            font-weight: bold;
            transition: width 0.5s ease-in-out;
        }
        #nav-controls {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #e0e0e0;
        }
        #nav-controls .btn {
            background-color: #607d8b;
            font-size: 0.9rem;
            padding: 10px 20px;
            width: auto;
        }
        #nav-controls .btn:hover {
            background-color: #546e7a;
        }
        #nav-controls .btn:disabled {
            background-color: #bdbdbd;
            cursor: not-allowed;
            transform: none;
        }
        #mode-selection-container {
            margin-bottom: 2rem;
            text-align: left;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 1.5rem;
        }
        #mode-selection-container label {
            display: block;
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        #mode-selection-container label:hover {
            background-color: #f0f2f5;
        }
        #mode-selection-container input[type="radio"] {
            margin-right: 10px;
            accent-color: #00695c;
            transform: scale(1.1);
        }
        /* å¯¼å…¥è¯åº“ç›¸å…³æ ·å¼ */
        #import-section {
            margin-top: 2rem;
            padding-top: 2rem;
        }

        .import-divider {
            width: 100%;
            height: 1px;
            background: linear-gradient(to right, transparent, #e0e0e0, transparent);
            margin-bottom: 1.5rem;
        }

        #import-section h3 {
            color: #37474f;
            margin-bottom: 1rem;
        }

        .import-btn {
            background-color: #1976d2;
            width: 80%;
            margin: 0.6rem auto;
        }

        .import-btn:hover {
            background-color: #1565c0;
        }

        #import-info {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #757575;
        }

        #import-info details {
            margin-top: 0.5rem;
            text-align: left;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
        }

        #import-info summary {
            cursor: pointer;
            color: #1976d2;
            font-weight: 500;
        }

        #import-info summary:hover {
            text-decoration: underline;
        }

        .format-example {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f5f5f5;
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .format-example pre {
            background-color: #fff;
            padding: 0.75rem;
            border-radius: 4px;
            overflow-x: auto;
            margin: 0.5rem 0;
            border: 1px solid #e0e0e0;
        }

        /* å¯¼å…¥æˆåŠŸ/å¤±è´¥æç¤º */
        .import-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .import-success {
            background-color: #43a047;
        }

        .import-error {
            background-color: #e53935;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>

    <div class="container">
    <div id="start-screen">
        <h1>é€‰æ‹©è¯åº“</h1>

        <div id="mode-selection-container">
            <label>
                <input type="radio" name="mode" value="zh-ar" checked> æ˜¾ç¤ºä¸­æ–‡èƒŒé˜¿è¯­
            </label>
            <label>
                <input type="radio" name="mode" value="ar-zh"> æ˜¾ç¤ºé˜¿è¯­èƒŒä¸­æ–‡
            </label>
            <label>
                <input type="radio" name="mode" value="mixed"> æ··åˆæ¨¡å¼
            </label>
        </div>

        <div id="deck-selection-container">
        </div>

        <div id="import-section">
            <div class="import-divider"></div>
            <h3>å¯¼å…¥æ–°è¯åº“</h3>
            <input type="file" id="file-input" accept=".json,.csv,.js,.txt" style="display: none;">
            <button id="import-btn" class="btn import-btn">
              ğŸ“ é€‰æ‹©æ–‡ä»¶å¯¼å…¥
            </button>
            <div id="import-info">
                <p>æ”¯æŒæ ¼å¼ï¼šJSONã€CSVã€JSå¯¹è±¡</p>
                <details>
                    <summary>æŸ¥çœ‹æ ¼å¼è¦æ±‚</summary>
                    <div class="format-example">
                        <strong>æ ¼å¼1 - å¤šè¯åº“æ‰¹é‡å¯¼å…¥ï¼ˆæ¨èï¼‰ï¼š</strong>
                        <pre>{
    "ç¬¬äºŒè¯¾ï¼šä½ å¥½": [
        {
        "chinese": "è° (ç–‘é—®ä»£è¯)",
        "arabic": "Ù…ÙÙ†Ù’",
        "explanation": "Ù…ÙÙ†Ù’ Ù‡ÙÙˆÙØŸ (ä»–æ˜¯è°ï¼Ÿ)"
        }
    ],
    "ç¬¬ä¸‰è¯¾ï¼šä½ å«ä»€ä¹ˆåå­—": [...]
    }</pre>
                        <strong>æ ¼å¼2 - å•è¯åº“JSONï¼š</strong>
                        <pre>{
    "deckName": "åŸºç¡€è¯æ±‡",
    "words": [
        {
        "chinese": "ä½ å¥½",
        "arabic": "Ù…Ø±Ø­Ø¨Ø§",
        "explanation": "å¸¸ç”¨é—®å€™è¯­"
        }
    ]
    }</pre>
                        <strong>æ ¼å¼3 - CSVè¡¨æ ¼ï¼š</strong>
                        <pre>ä¸­æ–‡,é˜¿æ‹‰ä¼¯è¯­,è§£é‡Š
    ä½ å¥½,Ù…Ø±Ø­Ø¨Ø§,å¸¸ç”¨é—®å€™è¯­
    è°¢è°¢,Ø´ÙƒØ±Ø§,è¡¨ç¤ºæ„Ÿè°¢</pre>
                    </div>
                </details>
            </div>
        </div>
    </div>

        <div id="card-container">
            <div id="progress-container">
                <div id="progress-bar">0%</div>
            </div>
            <h2 id="word-display"></h2>
            <div id="answer-display" class="spoiler" title="ç‚¹å‡»æ˜¾ç¤º/éšè—ç­”æ¡ˆ"></div>
   <p id="explanation-display" class="spoiler"></p>


            <div id="controls">
                <button id="remembered-btn" class="btn">è®°ä½äº†</button>
                <button id="forgot-btn" class="btn">æ²¡è®°ä½</button>
                <button id="next-word-in-history-btn" class="btn" style="display: none;">ä¸‹ä¸€ä¸ªè¯</button>
            </div>
            <div id="nav-controls">
                <button id="prev-btn" class="btn">ä¸Šä¸€ä¸ªè¯</button>
                <button id="back-to-menu-btn" class="btn">è¿”å›èœå•</button>
            </div>
        </div>

        <div id="completion-screen">
            <h2>ğŸ‰ æ­å–œä½ å®Œæˆäº†æœ¬è¯åº“çš„è®°å¿† ğŸ‰</h2>
            <p>æ‰€æœ‰å•è¯éƒ½å·²ç‰¢ç‰¢è®°ä½ï¼</p>
            <button id="finish-back-to-menu-btn" class="btn" style="background-color: #00695c;">è¿”å›èœå•</button>
        </div>
        <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e0e0e0;">
            <h3 style="color: #37474f; margin-bottom: 1rem;">æ•°æ®ç®¡ç†</h3>
            
            <!-- ç¬¬ä¸€è¡ŒæŒ‰é’® -->
            <button id="view-stats-btn" class="btn" style="background-color: #673ab7; width: 80%; margin: 0.6rem auto;">
                ğŸ“Š æŸ¥çœ‹å­¦ä¹ ç»Ÿè®¡
            </button>
            
            <!-- ç¬¬äºŒè¡ŒæŒ‰é’® -->
            <button id="export-backup-btn" class="btn" style="background-color: #00897b; width: 80%; margin: 0.6rem auto;">
                ğŸ’¾ å¯¼å‡ºå¤‡ä»½æ–‡ä»¶
            </button>
            
            <!-- ç¬¬ä¸‰è¡ŒæŒ‰é’® -->
            <button id="import-backup-btn" class="btn" style="background-color: #1976d2; width: 80%; margin: 0.6rem auto;">
                ğŸ“‚ å¯¼å…¥å¤‡ä»½æ–‡ä»¶
            </button>
            
            <!-- ç¬¬å››è¡ŒæŒ‰é’® -->
            <button id="check-storage-btn" class="btn" style="background-color: #ff6f00; width: 80%; margin: 0.6rem auto;">
                ğŸ’¿ æŸ¥çœ‹å­˜å‚¨ç©ºé—´
            </button>
            
            <!-- ç¬¬äº”è¡ŒæŒ‰é’®ï¼ˆå±é™©æ“ä½œï¼‰ -->
            <button id="clear-data-btn" class="btn" style="background-color: #f44336; width: 80%; margin: 0.6rem auto;">
                ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ•°æ®
            </button>
        </div>
    </div>

    <script>
        // --- NEW: Vocabulary Decks ---
        const vocabularyDecks = {

        };
        // ============= æœ¬åœ°å­˜å‚¨åŠŸèƒ½ =============
        const STORAGE_KEYS = {
            DECKS: 'arabic_vocabulary_decks',
            PROGRESS: 'arabic_learning_progress',
            SETTINGS: 'arabic_app_settings',
            STATS: 'arabic_learning_stats'
        };

        // åˆå§‹åŒ–ç»Ÿè®¡æ•°æ®
        let learningStats = {
            totalWordsLearned: 0,
            totalSessions: 0,
            lastStudyDate: null,
            streakDays: 0,
            dailyGoal: 20,
            todayWords: 0
        };

        // åŠ è½½æœ¬åœ°å­˜å‚¨çš„è¯åº“
        function loadDecksFromStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEYS.DECKS);
                if (stored) {
                    const decks = JSON.parse(stored);
                    Object.assign(vocabularyDecks, decks);
                    console.log(`å·²åŠ è½½ ${Object.keys(decks).length} ä¸ªè¯åº“`);
                }
            } catch (e) {
                console.error('åŠ è½½è¯åº“å¤±è´¥:', e);
            }
        }

        // ä¿å­˜è¯åº“åˆ°æœ¬åœ°å­˜å‚¨
        function saveDecksToStorage() {
            try {
                localStorage.setItem(STORAGE_KEYS.DECKS, JSON.stringify(vocabularyDecks));
                showImportMessage('è¯åº“å·²è‡ªåŠ¨ä¿å­˜åˆ°æœ¬åœ°', true);
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    showImportMessage('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·æ¸…ç†éƒ¨åˆ†è¯åº“', false);
                } else {
                    console.error('ä¿å­˜å¤±è´¥:', e);
                }
            }
        }

        // ä¿å­˜å­¦ä¹ è¿›åº¦
        function saveProgress() {
            const progress = {
                currentDeck: currentDeckName,
                wordStates: activeWords.map(w => ({
                    chinese: w.chinese,
                    arabic: w.arabic,
                    explanation: w.explanation,
                    rememberedCount: w.rememberedCount,
                    cooldown: w.cooldown,
                    mistakeCount: w.mistakeCount || 0,
                    stage: w.stage || 0,
                    nextReviewDate: w.nextReviewDate || null,
                    firstLearnedDate: w.firstLearnedDate || null
                })),
                lastUpdate: new Date().toISOString()
            };
            localStorage.setItem(STORAGE_KEYS.PROGRESS, JSON.stringify(progress));
        }

        // åŠ è½½å­¦ä¹ è¿›åº¦
        function loadProgress(deckName) {
            try {
                const stored = localStorage.getItem(STORAGE_KEYS.PROGRESS);
                if (stored) {
                    const progress = JSON.parse(stored);
                    if (progress.currentDeck === deckName) {
                        // æ¢å¤è¿›åº¦
                        const confirmRestore = confirm('æ£€æµ‹åˆ°ä¸Šæ¬¡çš„å­¦ä¹ è¿›åº¦ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ');
                        if (confirmRestore) {
                            return progress.wordStates;
                        }
                    }
                }
            } catch (e) {
                console.error('åŠ è½½è¿›åº¦å¤±è´¥:', e);
            }
            return null;
        }

        // æ›´æ–°æ¯æ—¥çŠ¶æ€å’Œè¿ç»­å¤©æ•°
        function updateDailyStatus() {
            const today = new Date().toDateString();
            const lastDate = learningStats.lastStudyDate;

            if (lastDate !== today) {
                learningStats.todayWords = 0; // é‡ç½®ä»Šæ—¥å­¦ä¹ å•è¯æ•°
                learningStats.lastStudyDate = today;

                if (lastDate) {
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    if (lastDate === yesterday.toDateString()) {
                        learningStats.streakDays++;
                    } else {
                        learningStats.streakDays = 1;
                    }
                } else {
                    learningStats.streakDays = 1;
                }
            }
        }

        // è®°å½•ä¸€ä¸ªå•è¯ä»Šæ—¥é¦–æ¬¡å­¦ä¼š
        function trackWordLearnedToday(word) {
            updateDailyStatus();
            // åªæœ‰å½“å•è¯ä»Šå¤©ç¬¬ä¸€æ¬¡è¢«æ ‡è®°ä¸ºå­¦ä¼šæ—¶ï¼ˆæˆ–åœ¨æ–°çš„ä¼šè¯æ—¥æœŸï¼‰ï¼Œæ‰è®¡æ•°
            if (!word.firstLearnedDate || word.firstLearnedDate !== sessionStartDate) {
                 word.firstLearnedDate = sessionStartDate;
                 learningStats.todayWords = (learningStats.todayWords || 0) + 1;
                 localStorage.setItem(STORAGE_KEYS.STATS, JSON.stringify(learningStats));
            }
        }

        // è®°å½•ä¸€ä¸ªå•è¯è¢«æŒæ¡
        function trackWordMastered(word) {
            // ç¡®ä¿åªè®¡æ•°ä¸€æ¬¡
            if (word.stage !== 4) {
                word.stage = 4; // æ ‡è®°ä¸ºå·²æŒæ¡
                learningStats.totalWordsLearned = (learningStats.totalWordsLearned || 0) + 1;
                localStorage.setItem(STORAGE_KEYS.STATS, JSON.stringify(learningStats));
            }
        }

        // æ¸…é™¤æ‰€æœ‰æ•°æ®
        function clearAllData() {
            if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®å—ï¼Ÿï¼ˆåŒ…æ‹¬è¯åº“å’Œå­¦ä¹ è¿›åº¦ï¼‰')) {
                localStorage.clear();
                location.reload();
            }
        }

        // å¯¼å‡ºæ‰€æœ‰æ•°æ®åˆ°æ–‡ä»¶
        function exportAllDataToFile() {
            const allData = {
                decks: JSON.parse(localStorage.getItem(STORAGE_KEYS.DECKS) || '{}'),
                progress: JSON.parse(localStorage.getItem(STORAGE_KEYS.PROGRESS) || '{}'),
                stats: JSON.parse(localStorage.getItem(STORAGE_KEYS.STATS) || '{}'),
                settings: JSON.parse(localStorage.getItem(STORAGE_KEYS.SETTINGS) || '{}'),
                exportDate: new Date().toISOString(),
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(allData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `é˜¿è¯­å­¦ä¹ å¤‡ä»½_${new Date().toLocaleDateString().replace(/\//g, '-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showImportMessage('âœ… æ•°æ®å·²å¯¼å‡ºåˆ°ä¸‹è½½æ–‡ä»¶å¤¹ï¼', true);
        }

        // å¯¼å…¥å¤‡ä»½æ–‡ä»¶
        function importBackupFile() {
            // åˆ›å»ºä¸€ä¸ªéšè—çš„æ–‡ä»¶è¾“å…¥
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const backup = JSON.parse(event.target.result);
                        
                        // éªŒè¯å¤‡ä»½æ–‡ä»¶æ ¼å¼
                        if (!backup.exportDate) {
                            throw new Error('ä¸æ˜¯æœ‰æ•ˆçš„å¤‡ä»½æ–‡ä»¶');
                        }
                        
                        const confirmMsg = `æ­¤å¤‡ä»½åˆ›å»ºäº ${new Date(backup.exportDate).toLocaleString()}\nç¡®å®šè¦æ¢å¤æ­¤å¤‡ä»½å—ï¼Ÿï¼ˆå°†è¦†ç›–å½“å‰æ‰€æœ‰æ•°æ®ï¼‰`;
                        
                        if (!confirm(confirmMsg)) return;
                        
                        // æ¢å¤æ•°æ®
                        if (backup.decks) {
                            localStorage.setItem(STORAGE_KEYS.DECKS, JSON.stringify(backup.decks));
                        }
                        if (backup.progress) {
                            localStorage.setItem(STORAGE_KEYS.PROGRESS, JSON.stringify(backup.progress));
                        }
                        if (backup.stats) {
                            localStorage.setItem(STORAGE_KEYS.STATS, JSON.stringify(backup.stats));
                        }
                        if (backup.settings) {
                            localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(backup.settings));
                        }
                        
                        showImportMessage('âœ… å¤‡ä»½æ¢å¤æˆåŠŸï¼å³å°†åˆ·æ–°é¡µé¢...', true);
                        setTimeout(() => location.reload(), 1500);
                        
                    } catch (err) {
                        showImportMessage('âŒ å¤‡ä»½æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼š' + err.message, false);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // æŸ¥çœ‹å­˜å‚¨ç©ºé—´ä½¿ç”¨æƒ…å†µ
        function checkStorageUsage() {
            let totalSize = 0;
            let details = {};
            
            for (let key in localStorage) {
         const value = localStorage.getItem(key); 

         const size = key.length + (value ? value.length : 0);
                totalSize += size;
                
                // è¯†åˆ«æ˜¯å“ªç§æ•°æ®
                if (key.includes('decks')) {
                    details['è¯åº“æ•°æ®'] = (size / 1024).toFixed(2) + ' KB';
                } else if (key.includes('progress')) {
                    details['å­¦ä¹ è¿›åº¦'] = (size / 1024).toFixed(2) + ' KB';
                } else if (key.includes('stats')) {
                    details['ç»Ÿè®¡æ•°æ®'] = (size / 1024).toFixed(2) + ' KB';
                }
            }
            
            const totalKB = (totalSize / 1024).toFixed(2);
            const usagePercent = ((totalSize / (5 * 1024 * 1024)) * 100).toFixed(1);
            
            let message = `ğŸ“Š å­˜å‚¨ç©ºé—´ä½¿ç”¨æƒ…å†µï¼š\n\n`;
            message += `æ€»ä½¿ç”¨é‡ï¼š${totalKB} KB (${usagePercent}%)\n`;
            message += `å‰©ä½™ç©ºé—´ï¼šçº¦ ${(5120 - parseFloat(totalKB)).toFixed(2)} KB\n\n`;
            message += `è¯¦ç»†åˆ†ç±»ï¼š\n`;
            
            for (let [type, size] of Object.entries(details)) {
                message += `  â€¢ ${type}ï¼š${size}\n`;
            }
            
            message += `\né¢„è®¡è¿˜å¯å¯¼å…¥çº¦ ${Math.floor((5120 - parseFloat(totalKB)) / 50)} ä¸ªè¯åº“`;
            
            alert(message);
        }

        // æ·»åŠ ä¸€ä¸ªå½“å‰è¯åº“åç§°å˜é‡
        let currentDeckName = '';
        // è·å–DOMå…ƒç´ 
        const startScreen = document.getElementById('start-screen');
        const cardContainer = document.getElementById('card-container');
        const completionScreen = document.getElementById('completion-screen');
        const deckSelectionContainer = document.getElementById('deck-selection-container');
        
        const wordDisplay = document.getElementById('word-display');
        const answerDisplay = document.getElementById('answer-display');
        const explanationDisplay = document.getElementById('explanation-display');
        
        const rememberedBtn = document.getElementById('remembered-btn');
        const forgotBtn = document.getElementById('forgot-btn');
        const prevBtn = document.getElementById('prev-btn');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');
        const finishBackToMenuBtn = document.getElementById('finish-back-to-menu-btn');
        const nextWordInHistoryBtn = document.getElementById('next-word-in-history-btn');

        const progressBar = document.getElementById('progress-bar');

        let activeWords = [];
        let currentWord = null;
        let historyStack = [];
        let currentMode = 'zh-ar'; // ç”¨äºå­˜å‚¨å½“å‰é€‰æ‹©çš„æ¨¡å¼
        let isReviewingHistory = false; // æ˜¯å¦æ­£åœ¨æŸ¥çœ‹å†å²è®°å½•
        let sessionStartDate = null; // æœ¬æ¬¡å­¦ä¹ ä¼šè¯çš„å¼€å§‹æ—¥æœŸ
        let isSessionActive = false; // æ ‡è®°å½“å‰å­¦ä¹ ä¼šè¯æ˜¯å¦å·²å¼€å§‹å®é™…å­¦ä¹ 
        // å¯¼å…¥åŠŸèƒ½ç›¸å…³å˜é‡
        const fileInput = document.getElementById('file-input');
        const importBtn = document.getElementById('import-btn');

        // æ˜¾ç¤ºå¯¼å…¥æ¶ˆæ¯
        function showImportMessage(message, isSuccess = true) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `import-message ${isSuccess ? 'import-success' : 'import-error'}`;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 3000);
        }

        // è§£æCSVæ–‡ä»¶
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSVæ–‡ä»¶æ ¼å¼é”™è¯¯ï¼šè‡³å°‘éœ€è¦æ ‡é¢˜è¡Œå’Œä¸€è¡Œæ•°æ®');
            }
            
            const words = [];
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',').map(part => part.trim());
                if (parts.length >= 2) {
                    words.push({
                        chinese: parts[0],
                        arabic: parts[1],
                        explanation: parts[2] || 'æš‚æ— è§£é‡Š'
                    });
                }
            }
            return words;
        }
        //è§£æjsonæ–‡ä»¶
        function parseJSON(jsonText) {
            try {
                // æ¸…ç†æ–‡æœ¬
                let cleanedText = jsonText.trim();
                
                // 1. å°è¯•ç›´æ¥è§£æä¸ºæ ‡å‡†JSON
                try {
                    const data = JSON.parse(cleanedText);
                    return processData(data);
                } catch (e) {
                    // ç»§ç»­å°è¯•å…¶ä»–æ ¼å¼
                }
                
                // 2. å¤„ç†å¯èƒ½çš„JavaScriptå¯¹è±¡æ ¼å¼
                // ç§»é™¤å¸¸è§çš„å˜é‡å£°æ˜
                cleanedText = cleanedText
                    .replace(/^(const|let|var)\s+\w+\s*=\s*/, '')  // ç§»é™¤å˜é‡å£°æ˜
                    .replace(/;[\s\n]*$/, '')  // ç§»é™¤æœ«å°¾åˆ†å·
                    .replace(/\/\*[\s\S]*?\*\//g, '')  // ç§»é™¤å¤šè¡Œæ³¨é‡Š
                    .replace(/\/\/.*$/gm, '');  // ç§»é™¤å•è¡Œæ³¨é‡Š
                
                // 3. æ£€æŸ¥æ˜¯å¦ç¼ºå°‘å¤–å±‚èŠ±æ‹¬å·
                cleanedText = cleanedText.trim();
                if (!cleanedText.startsWith('{')) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç›´æ¥çš„å±æ€§åˆ—è¡¨ï¼ˆå¦‚ "xxx": [...], "yyy": [...]ï¼‰
                    if (cleanedText.match(/^"[^"]+"\s*:/)) {
                        cleanedText = '{' + cleanedText;
                    }
                }
                if (!cleanedText.endsWith('}')) {
                    // ç§»é™¤æœ«å°¾å¯èƒ½çš„é€—å·
                    cleanedText = cleanedText.replace(/,\s*$/, '');
                    cleanedText = cleanedText + '}';
                }
                
                // 4. å°è¯•ä½œä¸ºJavaScriptå¯¹è±¡è§£æ
                try {
                    // ä½¿ç”¨æ›´å®‰å…¨çš„æ–¹å¼è§£æJavaScriptå¯¹è±¡
                    const data = new Function('return ' + cleanedText)();
                    return processData(data);
                } catch (e) {
                    // ç»§ç»­å°è¯•
                }
                
                // 5. æœ€åå°è¯•ï¼šä¿®å¤å¸¸è§çš„JSONé”™è¯¯
                cleanedText = cleanedText
                    .replace(/,\s*}/g, '}')  // ç§»é™¤å¯¹è±¡æœ«å°¾çš„é€—å·
                    .replace(/,\s*]/g, ']')  // ç§»é™¤æ•°ç»„æœ«å°¾çš„é€—å·
                    .replace(/'/g, '"')  // å°†å•å¼•å·æ›¿æ¢ä¸ºåŒå¼•å·
                    .replace(/(\w+):/g, '"$1":');  // ç»™æ²¡æœ‰å¼•å·çš„å±æ€§ååŠ å¼•å·
                
                const data = JSON.parse(cleanedText);
                return processData(data);
                
            } catch (error) {
                throw new Error(`è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚åŸå§‹é”™è¯¯ï¼š${error.message}`);
            }
        }

        // å¤„ç†è§£æåçš„æ•°æ®
        function processData(data) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯å•è¯åº“æ ¼å¼ï¼ˆæœ‰deckNameå’Œwordså­—æ®µï¼‰
            if (data.deckName && data.words && Array.isArray(data.words)) {
                // æ ¼å¼2ï¼šå•è¯åº“æ ¼å¼
                data.words.forEach((word, index) => {
                    if (!word.chinese || !word.arabic) {
                        throw new Error(`ç¬¬${index + 1}ä¸ªå•è¯ç¼ºå°‘å¿…è¦å­—æ®µï¼ˆchinese æˆ– arabicï¼‰`);
                    }
                    if (!word.explanation) {
                        word.explanation = 'æš‚æ— è§£é‡Š';
                    }
                });
                return { type: 'single', data: data };
            } else {
                // æ ¼å¼1ï¼šå¤šè¯åº“æ ¼å¼ï¼ˆå¯¹è±¡çš„æ¯ä¸ªå±æ€§éƒ½æ˜¯ä¸€ä¸ªè¯åº“ï¼‰
                const decks = {};
                let totalWords = 0;
                
                for (const [deckName, words] of Object.entries(data)) {
                    if (Array.isArray(words)) {
                        // éªŒè¯æ¯ä¸ªå•è¯
                        words.forEach((word, index) => {
                            if (!word.chinese || !word.arabic) {
                                throw new Error(`è¯åº“"${deckName}"çš„ç¬¬${index + 1}ä¸ªå•è¯ç¼ºå°‘å¿…è¦å­—æ®µ`);
                            }
                            if (!word.explanation) {
                                word.explanation = 'æš‚æ— è§£é‡Š';
                            }
                        });
                        decks[deckName] = words;
                        totalWords += words.length;
                    }
                }
                
                if (Object.keys(decks).length === 0) {
                    throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„è¯åº“æ•°æ®');
                }
        
        return { type: 'multiple', data: decks, totalWords: totalWords };
    }
}

        // å¤„ç†æ–‡ä»¶å¯¼å…¥
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    let importedCount = 0;
                    let importedDecks = [];
                    
                    if (file.name.endsWith('.csv')) {
                        // CSVæ ¼å¼å¤„ç†
                        const words = parseCSV(content);
                        let deckName = file.name.replace('.csv', '').replace(/[_-]/g, ' ');
                        
                        // å¦‚æœè¯åº“åç§°å·²å­˜åœ¨ï¼Œæ·»åŠ æ•°å­—åç¼€
                        let finalDeckName = deckName;
                        let counter = 1;
                        while (vocabularyDecks[finalDeckName]) {
                            finalDeckName = `${deckName} (${counter})`;
                            counter++;
                        }
                        
                        vocabularyDecks[finalDeckName] = words;
                        importedCount = words.length;
                        importedDecks.push(finalDeckName);
                        
                    } else {
                        // JSON/JSæ ¼å¼å¤„ç†
                        const result = parseJSON(content);
                        
                        if (result.type === 'single') {
                            // å•è¯åº“å¯¼å…¥
                            const data = result.data;
                            let deckName = data.deckName;
                            
                            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨
                            if (vocabularyDecks[deckName]) {
                                const overwrite = confirm(`è¯åº“"${deckName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`);
                                if (!overwrite) {
                                    // æ·»åŠ æ•°å­—åç¼€
                                    let counter = 1;
                                    while (vocabularyDecks[`${deckName} (${counter})`]) {
                                        counter++;
                                    }
                                    deckName = `${deckName} (${counter})`;
                                }
                            }
                            
                            vocabularyDecks[deckName] = data.words;
                            importedCount = data.words.length;
                            importedDecks.push(deckName);
                            
                        } else if (result.type === 'multiple') {
                            // å¤šè¯åº“æ‰¹é‡å¯¼å…¥
                            const decks = result.data;
                            let skippedDecks = [];
                            
                            for (const [deckName, words] of Object.entries(decks)) {
                                if (vocabularyDecks[deckName]) {
                                    const overwrite = confirm(`è¯åº“"${deckName}"å·²å­˜åœ¨ï¼ˆ${words.length}ä¸ªè¯ï¼‰ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`);
                                    if (!overwrite) {
                                        skippedDecks.push(deckName);
                                        continue;
                                    }
                                }
                                vocabularyDecks[deckName] = words;
                                importedDecks.push(deckName);
                                importedCount += words.length;
                            }
                            
                            // å¦‚æœæœ‰è·³è¿‡çš„è¯åº“ï¼Œæ˜¾ç¤ºæç¤º
                            if (skippedDecks.length > 0) {
                                setTimeout(() => {
                                    showImportMessage(`å·²è·³è¿‡ ${skippedDecks.length} ä¸ªå·²å­˜åœ¨çš„è¯åº“`, false);
                                }, 500);
                            }
                        }
                    }
                    
                    // åˆ·æ–°è¯åº“é€‰æ‹©ç•Œé¢
                    setupSelectionScreen();
                    //ä¿å­˜åˆ°æœ¬åœ°
                    saveDecksToStorage(); 
                    
                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    if (importedDecks.length === 1) {
                        showImportMessage(`æˆåŠŸå¯¼å…¥è¯åº“"${importedDecks[0]}"ï¼ˆ${importedCount}ä¸ªå•è¯ï¼‰`);
                    } else {
                        showImportMessage(`æˆåŠŸå¯¼å…¥ ${importedDecks.length} ä¸ªè¯åº“ï¼ˆå…±${importedCount}ä¸ªå•è¯ï¼‰`);
                    }
                    
                    // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
                    fileInput.value = '';
                    
                } catch (error) {
                    showImportMessage(`å¯¼å…¥å¤±è´¥ï¼š${error.message}`, false);
                    fileInput.value = '';
                }
            };
            
            reader.readAsText(file, 'UTF-8');
        }

        // å¯¼å…¥æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        importBtn.addEventListener('click', () => {
            fileInput.click();
        });

        // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
        fileInput.addEventListener('change', handleFileImport);

        // æŸ¥çœ‹ç»Ÿè®¡
        const viewStatsBtn = document.getElementById('view-stats-btn');
        if (viewStatsBtn) {
            viewStatsBtn.addEventListener('click', () => {
                const stats = JSON.parse(localStorage.getItem(STORAGE_KEYS.STATS) || '{}');
                const totalDecks = Object.keys(vocabularyDecks).length;
                const totalWords = Object.values(vocabularyDecks).reduce((sum, deck) => sum + deck.length, 0);
                
                alert(`ğŸ“Š å­¦ä¹ ç»Ÿè®¡ï¼š
                
        ğŸ“š è¯åº“æ•°é‡ï¼š${totalDecks}
        ğŸ“ æ€»è¯æ±‡é‡ï¼š${totalWords}
        âœ… å·²æŒæ¡ï¼š${stats.totalWordsLearned || 0}
        ğŸ“… è¿ç»­å­¦ä¹ ï¼š${stats.streakDays || 0} å¤©
        ğŸ¯ ä»Šæ—¥å­¦ä¹ ï¼š${stats.todayWords || 0} è¯
        ğŸ† æ€»å­¦ä¹ æ¬¡æ•°ï¼š${stats.totalSessions || 0}`);
            });
        }

        // å¯¼å‡ºå¤‡ä»½
        const exportBackupBtn = document.getElementById('export-backup-btn');
        if (exportBackupBtn) {
            exportBackupBtn.addEventListener('click', exportAllDataToFile);
        }

        // å¯¼å…¥å¤‡ä»½
        const importBackupBtn = document.getElementById('import-backup-btn');
        if (importBackupBtn) {
            importBackupBtn.addEventListener('click', importBackupFile);
        }

        // æŸ¥çœ‹å­˜å‚¨ç©ºé—´
        const checkStorageBtn = document.getElementById('check-storage-btn');
        if (checkStorageBtn) {
            checkStorageBtn.addEventListener('click', checkStorageUsage);
        }

        // æ¸…é™¤æ•°æ®
        const clearDataBtn = document.getElementById('clear-data-btn');
        if (clearDataBtn) {
            clearDataBtn.addEventListener('click', clearAllData);
        }


        function setupSelectionScreen() {
            deckSelectionContainer.innerHTML = '';
            Object.keys(vocabularyDecks).forEach(deckName => {
                const button = document.createElement('button');
                button.textContent = `${deckName} (${vocabularyDecks[deckName].length}è¯)`;  // æ˜¾ç¤ºè¯æ•°
                button.className = 'btn deck-btn';
                if (vocabularyDecks[deckName].length === 0) {
                    button.disabled = true;
                    button.title = 'æ­¤è¯åº“æš‚æ— å†…å®¹';
                }
                // ä¼ é€’ deckName å‚æ•°
                button.addEventListener('click', () => startSession(vocabularyDecks[deckName], deckName));
                deckSelectionContainer.appendChild(button);
            });
        }

        function showScreen(screen) {
            startScreen.style.display = 'none';
            cardContainer.style.display = 'none';
            completionScreen.style.display = 'none';
            screen.style.display = 'block';
        }
        
        function updateProgressBar() {
            if (activeWords.length === 0) return;
            // è¿›åº¦æ¡åæ˜ å·²ç»åˆæ­¥å­¦ä¼šï¼ˆè¿›å…¥å¤ä¹ é˜¶æ®µï¼‰çš„å•è¯æ¯”ä¾‹
            const learnedCount = activeWords.filter(w => (w.stage || 0) >= 1).length;
            const progress = Math.round((learnedCount / activeWords.length) * 100);
            progressBar.style.width = progress + '%';
            progressBar.textContent = progress + '%';
        }

                function displayCard(word) {
            explanationDisplay.textContent = `ğŸ’¡ è§£é‡Š: ${word.explanation}`;

            let showChinese = true; // é»˜è®¤æ˜¾ç¤ºä¸­æ–‡

            // æ ¹æ®å…¨å±€å˜é‡ currentMode å†³å®šæ˜¾ç¤ºå†…å®¹
            if (currentMode === 'mixed') {
                showChinese = Math.random() < 0.5; // æ··åˆæ¨¡å¼ï¼šéšæœº
            } else if (currentMode === 'ar-zh') {
                showChinese = false; // é˜¿èƒŒä¸­ï¼šä¸æ˜¾ç¤ºä¸­æ–‡
            }
            // (å¦‚æœ currentMode === 'zh-ar', showChinese ä¿æŒä¸º true)

            if (showChinese) {
                // æ¨¡å¼ "zh-ar" æˆ– æ··åˆæ¨¡å¼çš„ä¸­æ–‡é¢
                wordDisplay.textContent = word.chinese;
                wordDisplay.style.direction = 'ltr';
                answerDisplay.innerHTML = word.arabic.replace(/\n/g, '<br>');
                answerDisplay.style.direction = 'rtl';
            } else {
                // æ¨¡å¼ "ar-zh" æˆ– æ··åˆæ¨¡å¼çš„é˜¿è¯­é¢
                wordDisplay.innerHTML = word.arabic.replace(/\n/g, '<br>');
                wordDisplay.style.direction = 'rtl';
                answerDisplay.textContent = word.chinese;
                answerDisplay.style.direction = 'ltr';
            }

            // é‡ç½®ç­”æ¡ˆä¸ºéšè—çŠ¶æ€
            answerDisplay.classList.remove('revealed');
            answerDisplay.classList.add('spoiler');
            
            // é‡ç½®è§£é‡Šä¸ºéšè—çŠ¶æ€ (ç¡®ä¿è¿™ä¸€æ­¥ä¹ŸåŒ…å«åœ¨å†…)
            explanationDisplay.classList.remove('revealed');
            explanationDisplay.classList.add('spoiler');
        }

function startSession(vocabulary, deckName) {  // æ·»åŠ  deckName å‚æ•°
    currentDeckName = deckName;  // ä¿å­˜å½“å‰è¯åº“å
    sessionStartDate = new Date().toDateString(); // è®°å½•ä¼šè¯å¼€å§‹æ—¥æœŸ
    
    const selectedMode = document.querySelector('input[name="mode"]:checked');
    if (selectedMode) {
        currentMode = selectedMode.value;
    } else {
        currentMode = 'zh-ar';
    }
    
    // å°è¯•åŠ è½½ä¹‹å‰çš„è¿›åº¦
    const savedProgress = loadProgress(deckName);
    if (savedProgress) {
        activeWords = vocabulary.map(word => {
            const saved = savedProgress.find(s => 
                s.chinese === word.chinese && s.arabic === word.arabic
            );
            // åˆå¹¶ï¼Œç¡®ä¿æ–°æ—§æ•°æ®ç»“æ„éƒ½èƒ½å…¼å®¹
            return {
                ...word,
                rememberedCount: 0,
                cooldown: 0,
                mistakeCount: 0,
                stage: 0,
                nextReviewDate: null,
                firstLearnedDate: null,
                ...saved // ç”¨ä¿å­˜çš„æ•°æ®è¦†ç›–é»˜è®¤å€¼
            };
        });
    } else {
        initialize(vocabulary);
    }
    
    showScreen(cardContainer);
    showNextWord();
    
    // ç»Ÿè®¡æ›´æ–°ç§»è‡³ç¬¬ä¸€æ¬¡ç‚¹å‡»â€œè®°ä½äº†â€æˆ–â€œæ²¡è®°ä½â€æ—¶
}
    // é‡ç½®ç­”æ¡ˆä¸ºéšè—çŠ¶æ€
    answerDisplay.classList.remove('revealed');
    answerDisplay.classList.add('spoiler');
    // æ–°å¢ï¼šé‡ç½®è§£é‡Šä¸ºéšè—çŠ¶æ€    explanationDisplay.classList.remove('revealed');
    explanationDisplay.classList.add('spoiler');
        function initialize(vocabulary) {
            activeWords = vocabulary.map(word => ({
                ...word,
                rememberedCount: 0,
                cooldown: 0,
                mistakeCount: 0,
                stage: 0, // 0: learning, 1: 3d, 2: 7d, 3: 30d, 4: mastered
                nextReviewDate: null,
                firstLearnedDate: null
            }));
            historyStack = [];
            currentWord = null;
            updateProgressBar();
        }

        function showNextWord() {
            // é€€å‡ºå†å²è®°å½•åªè¯»æ¨¡å¼
            isReviewingHistory = false;
            rememberedBtn.style.display = 'inline-block'; // æ˜¾ç¤º
            forgotBtn.style.display = 'inline-block'; // æ˜¾ç¤º
            nextWordInHistoryBtn.style.display = 'none'; // éšè—
            rememberedBtn.disabled = false;
            forgotBtn.disabled = false;

            if (currentWord) {
                historyStack.push(currentWord);
            }
            prevBtn.disabled = historyStack.length === 0;

            activeWords.forEach(w => {
                if (w.cooldown > 0) w.cooldown--;
            });

            const today = new Date();
            
            // æ£€æŸ¥ä»Šå¤©æ˜¯å¦è¿˜æœ‰ä»»åŠ¡
            const hasLearningWords = activeWords.some(w => (w.stage || 0) === 0);
            const hasReviewWordsToday = activeWords.some(w => 
                w.stage > 0 && 
                w.nextReviewDate && 
                new Date(w.nextReviewDate) <= today
            );

            // å¦‚æœæ‰€æœ‰å•è¯éƒ½å·²è¿›å…¥å¤ä¹ é˜¶æ®µï¼Œå¹¶ä¸”ä»Šå¤©æ²¡æœ‰åˆ°æœŸçš„å¤ä¹ è¯ï¼Œåˆ™ç»“æŸ
            if (!hasLearningWords && !hasReviewWordsToday) {
                // åœ¨æ˜¾ç¤ºå®Œæˆå‰ï¼Œå†ç¡®è®¤ä¸€ä¸‹æ˜¯å¦æ‰€æœ‰è¯éƒ½å½»åº•æŒæ¡äº†
                const allMastered = activeWords.every(w => (w.stage || 0) >= 4);
                if (!allMastered) {
                     // å¦‚æœåªæ˜¯ä»Šå¤©æ²¡ä»»åŠ¡ï¼Œå¯ä»¥ç»™ä¸ªä¸åŒçš„æç¤º
                    completionScreen.querySelector('h2').textContent = 'ğŸ‰ æ­å–œï¼ä»Šæ—¥ä»»åŠ¡å·²å…¨éƒ¨å®Œæˆ ğŸ‰';
                    completionScreen.querySelector('p').textContent = 'è¯·æ˜å¤©å†æ¥å¤ä¹ å§ï¼';
                } else {
                    completionScreen.querySelector('h2').textContent = 'ğŸ‰ æ­å–œä½ å®Œæˆäº†æœ¬è¯åº“çš„è®°å¿† ğŸ‰';
                    completionScreen.querySelector('p').textContent = 'æ‰€æœ‰å•è¯éƒ½å·²ç‰¢ç‰¢è®°ä½ï¼';
                }
                showScreen(completionScreen);
                return;
            }

            // ç­›é€‰å‡ºæ‰€æœ‰æœªæŒæ¡çš„è¯
            let wordsToLearn = activeWords.filter(w => (w.stage || 0) < 4);

            // 1. ä¼˜å…ˆé€‰æ‹©åˆ°æœŸçš„å¤ä¹ è¯ (ç§»é™¤cooldowné™åˆ¶)
            let reviewPool = wordsToLearn.filter(w => 
                w.stage > 0 && 
                w.nextReviewDate && 
                new Date(w.nextReviewDate) <= today
            );

            if (reviewPool.length > 0) {
                const randomIndex = Math.floor(Math.random() * reviewPool.length);
                currentWord = reviewPool[randomIndex];
                displayCard(currentWord);
                updateProgressBar();
                return;
            }

            // 2. å¦‚æœæ²¡æœ‰å¤ä¹ è¯ï¼Œé€‰æ‹©å­¦ä¹ é˜¶æ®µçš„è¯
            let learningPool = wordsToLearn.filter(w => (w.stage || 0) === 0 && w.cooldown === 0);

            if (learningPool.length > 0) {
                const randomIndex = Math.floor(Math.random() * learningPool.length);
                currentWord = learningPool[randomIndex];
            } else {
                // 3. å¦‚æœéƒ½æ²¡æœ‰ï¼ˆæ„å‘³ç€ä»Šå¤©çš„ä»»åŠ¡å®Œæˆäº†ï¼Œä½†ä¸Šé¢é‚£ä¸ªåˆ¤æ–­æ²¡æ‹¦ä½ï¼Œæˆ–è€…æœ‰è¯åœ¨å†·å´ä¸­ï¼‰
                // æ­¤æ—¶ä¸åº”è¯¥å¡ä½ï¼Œè€Œæ˜¯æ˜¾ç¤ºå®Œæˆç•Œé¢
                completionScreen.querySelector('h2').textContent = 'ğŸ‰ æ­å–œï¼ä»Šæ—¥ä»»åŠ¡å·²å…¨éƒ¨å®Œæˆ ğŸ‰';
                completionScreen.querySelector('p').textContent = 'è¯·æ˜å¤©å†æ¥å¤ä¹ å§ï¼';
                showScreen(completionScreen);
                return;
            }
            
            displayCard(currentWord);
            updateProgressBar();
        }
        
        // --- Event Listeners ---
                
        answerDisplay.addEventListener('click', () => {
            // åˆ‡æ¢ç­”æ¡ˆçš„æ˜¾ç¤º
            answerDisplay.classList.toggle('spoiler');
            answerDisplay.classList.toggle('revealed');

            // åŒæ—¶åˆ‡æ¢è§£é‡Šçš„æ˜¾ç¤º
            explanationDisplay.classList.toggle('spoiler');
            explanationDisplay.classList.toggle('revealed');
        });

        rememberedBtn.addEventListener('click', () => {
            if (!currentWord || isReviewingHistory) return;

            const today = new Date();

            if (!isSessionActive) {
                learningStats.totalSessions = (learningStats.totalSessions || 0) + 1; // é¦–æ¬¡å­¦ä¹ æ‰å¢åŠ æ€»ä¼šè¯æ•°
                updateDailyStatus(); // æ›´æ–°æ¯æ—¥çŠ¶æ€ï¼ˆä»Šæ—¥å­¦ä¹ ã€è¿ç»­å¤©æ•°ï¼‰
                localStorage.setItem(STORAGE_KEYS.STATS, JSON.stringify(learningStats)); // ä¿å­˜ç»Ÿè®¡æ•°æ®
                isSessionActive = true; // æ ‡è®°ä¼šè¯å·²æ¿€æ´»
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯åˆ°æœŸçš„å¤ä¹ è¯
            if (currentWord.stage > 0 && currentWord.nextReviewDate && new Date(currentWord.nextReviewDate) <= today) {
                currentWord.stage++; // è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                
                let nextReviewDays = null;
                if (currentWord.stage === 2) nextReviewDays = 7;
                if (currentWord.stage === 3) nextReviewDays = 30;

                if (nextReviewDays) {
                    const nextDate = new Date();
                    nextDate.setDate(today.getDate() + nextReviewDays);
                    currentWord.nextReviewDate = nextDate.toISOString();
                } else if (currentWord.stage >= 4) {
                    // å·²æŒæ¡
                    trackWordMastered(currentWord);
                    currentWord.nextReviewDate = null;
                }
            } else if ((currentWord.stage || 0) === 0) {
                // å­¦ä¹ é˜¶æ®µ
                currentWord.rememberedCount++;
                if (currentWord.rememberedCount === 3) {
                    currentWord.stage = 1; // è¿›å…¥3å¤©å¤ä¹ é˜¶æ®µ
                    const nextDate = new Date();
                    nextDate.setDate(today.getDate() + 3);
                    currentWord.nextReviewDate = nextDate.toISOString();
                    trackWordLearnedToday(currentWord); // ç»Ÿè®¡ä»Šæ—¥å­¦ä¹ 
                }
            }

            currentWord.cooldown = 11;
            saveProgress();
            showNextWord();
        });

        forgotBtn.addEventListener('click', () => {
            if (!currentWord || isReviewingHistory) return;

            if (!isSessionActive) {
                learningStats.totalSessions = (learningStats.totalSessions || 0) + 1; // é¦–æ¬¡å­¦ä¹ æ‰å¢åŠ æ€»ä¼šè¯æ•°
                updateDailyStatus(); // æ›´æ–°æ¯æ—¥çŠ¶æ€ï¼ˆä»Šæ—¥å­¦ä¹ ã€è¿ç»­å¤©æ•°ï¼‰
                localStorage.setItem(STORAGE_KEYS.STATS, JSON.stringify(learningStats)); // ä¿å­˜ç»Ÿè®¡æ•°æ®
                isSessionActive = true; // æ ‡è®°ä¼šè¯å·²æ¿€æ´»
            }
            
            // å¦‚æœæ˜¯å¤ä¹ é˜¶æ®µçš„è¯å¿˜äº†ï¼Œåˆ™é‡ç½®å­¦ä¹ é˜¶æ®µ
            if (currentWord.stage > 0) {
                currentWord.stage = 0;
                currentWord.rememberedCount = 0; // é‡ç½®è®°å¿†æ¬¡æ•°
                currentWord.nextReviewDate = null;
            }

            currentWord.cooldown = Math.floor(Math.random() * 4) + 2;
            currentWord.mistakeCount = (currentWord.mistakeCount || 0) + 1;
            saveProgress();
            showNextWord();
        });

        prevBtn.addEventListener('click', () => {
            if (historyStack.length > 0) {
                currentWord = historyStack.pop();
                displayCard(currentWord);
                prevBtn.disabled = historyStack.length === 0;

                // è¿›å…¥å†å²è®°å½•åªè¯»æ¨¡å¼
                isReviewingHistory = true;
                rememberedBtn.style.display = 'none'; // éšè—
                forgotBtn.style.display = 'none'; // éšè—
                nextWordInHistoryBtn.style.display = 'block'; // æ˜¾ç¤ºå¹¶å±…ä¸­
            }
        });

        const goBackToMenu = () => {
            showScreen(startScreen);
            isSessionActive = false; // é‡ç½®ä¼šè¯æ¿€æ´»çŠ¶æ€
        };

        backToMenuBtn.addEventListener('click', goBackToMenu);
        finishBackToMenuBtn.addEventListener('click', goBackToMenu);

        nextWordInHistoryBtn.addEventListener('click', () => {
            showNextWord();
        });

        // --- Initial Load ---
        window.onload = () => {
            loadDecksFromStorage();

            const savedStats = localStorage.getItem(STORAGE_KEYS.STATS);
            if (savedStats) {
                learningStats = JSON.parse(savedStats);
            }
            
            setupSelectionScreen();
            showScreen(startScreen);
        };

    </script>

</body>
</html>
